---
version: 1.4.1
title: Response serializer with nested types
---
import gleam/dynamic/decode
import gleam/http/request.{type Request}
import gleam/json
import squall
import gleam/option.{type Option}

pub type User {
  User(id: String, name: String, location: Option(Location))
}

pub fn user_decoder() -> decode.Decoder(User) {
  use id <- decode.field("id", decode.string)
  use name <- decode.field("name", decode.string)
  use location <- decode.field("location", decode.optional(location_decoder()))
  decode.success(User(id: id, name: name, location: location))
}

pub type Location {
  Location(city: Option(String), country: Option(String))
}

pub fn location_decoder() -> decode.Decoder(Location) {
  use city <- decode.field("city", decode.optional(decode.string))
  use country <- decode.field("country", decode.optional(decode.string))
  decode.success(Location(city: city, country: country))
}

pub fn user_to_json(input: User) -> json.Json {
  json.object(
    [
      #("id", json.string(input.id)),
      #("name", json.string(input.name)),
      #("location", json.nullable(input.location, location_to_json)),
    ],
  )
}

pub fn location_to_json(input: Location) -> json.Json {
  json.object(
    [
      #("city", json.nullable(input.city, json.string)),
      #("country", json.nullable(input.country, json.string)),
    ],
  )
}

pub type GetUserResponse {
  GetUserResponse(user: Option(User))
}

pub fn get_user_response_decoder() -> decode.Decoder(GetUserResponse) {
  use user <- decode.field("user", decode.optional(user_decoder()))
  decode.success(GetUserResponse(user: user))
}

pub fn get_user_response_to_json(input: GetUserResponse) -> json.Json {
  json.object([#("user", json.nullable(input.user, user_to_json))])
}

pub fn get_user(client: squall.Client) -> Result(Request(String), String) {
  squall.prepare_request(
    client,
    "query GetUser { user { id name location { city country } } }",
    json.object([]),
  )
}

pub fn parse_get_user_response(body: String) -> Result(GetUserResponse, String) {
  squall.parse_response(body, get_user_response_decoder())
}

