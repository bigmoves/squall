---
version: 1.4.1
title: Query with inline array arguments
---
import gleam/dynamic/decode
import gleam/http/request.{type Request}
import gleam/json
import squall
import gleam/option.{type Option}

pub type Episode {
  Episode(id: String, name: String)
}

pub fn episode_decoder() -> decode.Decoder(Episode) {
  use id <- decode.field("id", decode.string)
  use name <- decode.field("name", decode.string)
  decode.success(Episode(id: id, name: name))
}

pub fn episode_to_json(input: Episode) -> json.Json {
  json.object(
    [
      #("id", json.string(input.id)),
      #("name", json.string(input.name)),
    ],
  )
}

pub type GetEpisodesResponse {
  GetEpisodesResponse(episodes_by_ids: Option(List(Episode)))
}

pub fn get_episodes_response_decoder() -> decode.Decoder(GetEpisodesResponse) {
  use episodes_by_ids <- decode.field("episodesByIds", decode.optional(decode.list(episode_decoder())))
  decode.success(GetEpisodesResponse(episodes_by_ids: episodes_by_ids))
}

pub fn get_episodes_response_to_json(input: GetEpisodesResponse) -> json.Json {
  json.object(
    [
      #("episodesByIds", json.nullable(
        input.episodes_by_ids,
        fn(list) { json.array(from: list, of: episode_to_json) },
      )),
    ],
  )
}

pub fn get_episodes(client: squall.Client) -> Result(Request(String), String) {
  squall.prepare_request(
    client,
    "query GetEpisodes { episodesByIds(ids: [1, 2, 3]) { id name } }",
    json.object([]),
  )
}

pub fn parse_get_episodes_response(body: String) -> Result(GetEpisodesResponse, String) {
  squall.parse_response(body, get_episodes_response_decoder())
}

