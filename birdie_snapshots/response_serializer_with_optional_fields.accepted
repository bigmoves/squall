---
version: 1.4.1
title: Response serializer with optional fields
file: ./test/codegen_test.gleam
test_name: generate_response_serializer_with_optional_fields_test
---
import gleam/dynamic/decode
import gleam/http/request.{type Request}
import gleam/json
import squall
import gleam/option.{type Option}

pub type User {
  User(id: String, name: Option(String), email: Option(String))
}

pub fn user_decoder() -> decode.Decoder(User) {
  use id <- decode.field("id", decode.string)
  use name <- decode.field("name", decode.optional(decode.string))
  use email <- decode.field("email", decode.optional(decode.string))
  decode.success(User(id: id, name: name, email: email))
}

pub fn user_to_json(input: User) -> json.Json {
  json.object(
    [
      #("id", json.string(input.id)),
      #("name", json.nullable(input.name, json.string)),
      #("email", json.nullable(input.email, json.string)),
    ],
  )
}

pub type GetUserResponse {
  GetUserResponse(user: Option(User))
}

pub fn get_user_response_decoder() -> decode.Decoder(GetUserResponse) {
  use user <- decode.field("user", decode.optional(user_decoder()))
  decode.success(GetUserResponse(user: user))
}

pub fn get_user_response_to_json(input: GetUserResponse) -> json.Json {
  json.object([#("user", json.nullable(input.user, user_to_json))])
}

pub fn get_user(client: squall.Client) -> Result(Request(String), String) {
  squall.prepare_request(
    client,
    "\n    query GetUser {\n      user {\n        id\n        name\n        email\n      }\n    }\n  ",
    json.object([]),
  )
}

pub fn parse_get_user_response(body: String) -> Result(GetUserResponse, String) {
  squall.parse_response(body, get_user_response_decoder())
}

