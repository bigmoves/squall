---
version: 1.4.1
title: Mutation function generation
---
import gleam/dynamic/decode
import gleam/http/request.{type Request}
import gleam/json
import squall
import gleam/option.{type Option}

pub type User {
  User(id: String, name: String)
}

pub fn user_decoder() -> decode.Decoder(User) {
  use id <- decode.field("id", decode.string)
  use name <- decode.field("name", decode.string)
  decode.success(User(id: id, name: name))
}

pub fn user_to_json(input: User) -> json.Json {
  json.object(
    [
      #("id", json.string(input.id)),
      #("name", json.string(input.name)),
    ],
  )
}

pub type CreateUserResponse {
  CreateUserResponse(create_user: Option(User))
}

pub fn create_user_response_decoder() -> decode.Decoder(CreateUserResponse) {
  use create_user <- decode.field("createUser", decode.optional(user_decoder()))
  decode.success(CreateUserResponse(create_user: create_user))
}

pub fn create_user_response_to_json(input: CreateUserResponse) -> json.Json {
  json.object([#("createUser", json.nullable(input.create_user, user_to_json))])
}

pub fn create_user(client: squall.Client, name: String) -> Result(Request(String), String) {
  squall.prepare_request(
    client,
    "mutation CreateUser($name: String!) { createUser(name: $name) { id name } }",
    json.object([#("name", json.string(name))]),
  )
}

pub fn parse_create_user_response(body: String) -> Result(CreateUserResponse, String) {
  squall.parse_response(body, create_user_response_decoder())
}

